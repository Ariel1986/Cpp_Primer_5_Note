#### 重载运算符 overloaded operator
+ 使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数，运算符的优先级和结合律都是无法改变的。

+ 要用到左值的运算符
  * 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果仍是一个左值
  * 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
  * 内置解引用运算符，下标运算符，迭代器解引用运算符，string和vector的下标运算符的求职结果都是左值。
  * 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值
  
#### 求值顺序
+ 有4种运算符明确规定了运算对象的求值顺序：
   * 逻辑与（&&）运算符
   * 逻辑或（｜｜）运算符
   * 条件（？：）运算符
   * 逗号（，）运算符
   
#### 递增和递减运算符
+ 前置版本将对象本身作为左值返回；后置版本则将对象原始值的副本作为右值返回。 所以除非必须，否则不用递增递减运算符的后置版本。

#### 成员访问运算符
+ 点运算符获取对象的一个成员
+ 箭头运算符与点运算符有关，ptr->mem <=> (*ptr).mem
```
string s1 = "a string", *p = &s1;
auto n = s1.size();  //运行string对象s1的size成员
n = (*p).size();     //运行p所指对象的size成员，括号必不可少，因为解引用运算符的优先级低于点运算符
n = p->size();       //等价于(*p).size() 
```

#### 条件运算符（？：）
+ cond? expr1:expr2; 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则运算的结果是右值。

#### sizeof运算符
+ sizeof (type)和sizeof expr两种形式
+ C++11允许使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须提供一个具体的对象，因为想知道类成员的大小无须真的获取该成员。

#### 类型转换
+ 何时发生隐式类型转换
  * 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
  * 在条件中，非布尔值转换成布尔类型
  * 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
  * 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
  * 函数调用时也会发生类型转换

#### 算术转换 arithmetic conversion
+ 整型提升 integral promotion
 * 把小整数类型转换成较大的整数类型。bool，char，signed char，unsigned char，short和unsigned short等类型，只要它们所有可能的值都能存在int里，它们就会提升成int类型；否则提升成unsigned int类型。如布尔值false提升成0，true提升成1.
 * 较大的char类型（wchar_t,char16_t,char32_t)提升成int，unsigned int，long，unsigned long，long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。
 
#### 其他隐士类型转换
+ 数组转换成指针：大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针，但是如下情况不会发生此类转换：
 * 数组被用作decltype关键字的参数
 * 作为取地址符（&）
 * sizeof运算符的运算对象
 * typeid运算符的运算对象
 * 用一个引用来初始化数组，上述转换也不会发生

+ 指针的转换
 * 常量整数值0或者字面值nullptr能转换成任意指针类型
 * 指向任意非常量的指针能转换成void*
 * 指向任意对象的指针能转换成const void*
+ 转换成布尔类型
 * 从算术类型或指针类型自动转换成布尔类型，如果指针或算术类型的值为0，转换结果为false，否则结果为true。
+ 转换成常量
 * 非常量类型的指针或引用转换成指向相应的常量类型的指针或引用。相反的转换不存在。
```
int i;
const int &j = i;   //非常量转换成const int的引用
const int *p = &i;  //非常量的地址转换成const的地址
int &r = j, *q = p; //Error：不允许const转换成非常量
```
+ 类类型定义的转换
 * 类类型能定义由编译器自动执行的转换，不过编译器每次只能之行一种类类型的转换。如果同时提出多个转换请求，这些请求将被拒绝。
 
#### 显式转换
+ 命名的强制类型转换形式：
 * cast_name<type>(expression); //如果type是引用类型，则结果是左值
 * cast_name是static_cast, dynamic_cast, const_caset, reinterpret_cast中的一种。
 
+ static_cast
 * 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast.
```
double slope = static_cast<double>(j); 
```
 * 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。
 * static_cast对于编译器无法自动执行的类型转换也非常有用。例如可以用static_cast找回存在于void*指针中的值。此时必须保证转换后所得的类型就是指针所指的类型。类型一旦不符，将产生为定义的后果。
```
void *p = &d;   //正确：任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p);  //正确：将void*转换回初始的指针类型，如果将void*转换成其他的指针类型，结果是为定义的
```
+ const_cast
 * const_cast只能改变运算对象的底层const。
 ```
 const char* pc;
 char *p = const_cast<char*>(pc);  //正确，但是通过p写值是未定义的行为
 ```
 * 对于将常量对象转换成非常量对象的行为，称为“去掉const性质（cast away the const）”。一旦去掉了某个对象的const性质，编译器将不再阻止对该对象进行写操作。如果对象本事不是一个常量，使用强制类型转换获得写权限是合法的行为。如果对象是一个常量，再使用const_cast执行写操作会产生为定义的后果。
 * 只有const_cast能改变表达式的常量属性，使用其他形式的命名强制转换改变表达式的常量属性都将引发编译错误。同样，也不能用const_cast改变表达式的类型。
```
const char *cp;
char *q = static_cast<char*>(cp);   //错误：static_cast不能转换掉const性质
static_cast<string>(cp);            //正确：字符串字面值转换成string类型
const_cast<string>(cp);             //错误：const_cast只改变常量属性
```
 * const_cast常常用于有函数重载的上下文中。

+ 

 
