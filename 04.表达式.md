#### 重载运算符 overloaded operator
+ 使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数，运算符的优先级和结合律都是无法改变的。

+ 要用到左值的运算符
  * 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果仍是一个左值
  * 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
  * 内置解引用运算符，下标运算符，迭代器解引用运算符，string和vector的下标运算符的求职结果都是左值。
  * 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值
  
#### 求值顺序
+ 有4种运算符明确规定了运算对象的求值顺序：
   * 逻辑与（&&）运算符
   * 逻辑或（｜｜）运算符
   * 条件（？：）运算符
   * 逗号（，）运算符
   
#### 递增和递减运算符
+ 前置版本将对象本身作为左值返回；后置版本则将对象原始值的副本作为右值返回。 所以除非必须，否则不用递增递减运算符的后置版本。

#### 成员访问运算符
+ 点运算符获取对象的一个成员
+ 箭头运算符与点运算符有关，ptr->mem <=> (*ptr).mem
```
string s1 = "a string", *p = &s1;
auto n = s1.size();  //运行string对象s1的size成员
n = (*p).size();     //运行p所指对象的size成员，括号必不可少，因为解引用运算符的优先级低于点运算符
n = p->size();       //等价于(*p).size() 
```

#### 条件运算符（？：）
+ cond? expr1:expr2; 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则运算的结果是右值。

#### sizeof运算符
+ sizeof (type)和sizeof expr两种形式
+ C++11允许使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须提供一个具体的对象，因为想知道类成员的大小无须真的获取该成员。

#### 类型转换
+ 何时发生隐式类型转换
  * 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
  * 在条件中，非布尔值转换成布尔类型
  * 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
  * 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
  * 函数调用时也会发生类型转换

#### 算术转换 arithmetic conversion
+ 整型提升 integral promotion
 * 把小整数类型转换成较大的整数类型。bool，char，signed char，unsigned char，short和unsigned short等类型，只要它们所有可能的值都能存在int里，它们就会提升成int类型；否则提升成unsigned int类型。如布尔值false提升成0，true提升成1.
 * 较大的char类型（wchar_t,char16_t,char32_t)提升成int，unsigned int，long，unsigned long，long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。
 
#### 其他隐士类型转换
+ 数组转换成指针：大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针，但是如下情况不会发生此类转换：
 * 数组被用作decltype关键字的参数
 * 作为取地址符（&）
 * sizeof运算符的运算对象
 * typeid运算符的运算对象
 * 用一个引用来初始化数组，上述转换也不会发生

+ 指针的转换
 * 常量整数值0或者字面值nullptr能转换成任意指针类型
 * 指向任意非常量的指针能转换成void*
 * 指向任意对象的指针能转换成const void*
+ 转换成布尔类型
 * 从算术类型或指针类型自动转换成布尔类型，如果指针或算术类型的值为0，转换结果为false，否则结果为true。
+ 转换成常量
 * 非常量类型的指针或引用转换成指向相应的常量类型的指针或引用。相反的转换不存在。
```
int i;
const int &j = i;   //非常量转换成const int的引用
const int *p = &i;  //非常量的地址转换成const的地址
int &r = j, *q = p; //Error：不允许const转换成非常量
```
+ 类类型定义的转换
 * 类类型能定义由编译器自动执行的转换，不过编译器每次只能之行一种类类型的转换。如果同时提出多个转换请求，这些请求将被拒绝。
 
#### 显式转换
+ 命名的强制类型转换形式：
 * cast_name<type>(expression); //如果type是引用类型，则结果是左值
 * cast_name是static_cast, dynamic_cast, const_caset, reinterpret_cast中的一种。
 
+ static_cast
 * 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast.
```
double slope = static_cast<double>(j); 
```
 * 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。
 * static_cast对于编译器无法自动执行的类型转换也非常有用。例如可以用static_cast找回存在于void*指针中的值。此时必须保证转换后所得的类型就是指针所指的类型。类型一旦不符，将产生为定义的后果。
```
void *p = &d;   //正确：任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p);  //正确：将void*转换回初始的指针类型，如果将void*转换成其他的指针类型，结果是为定义的
```
+ const_cast
 * const_cast只能改变运算对象的底层const。
 ```
 const char* pc;
 char *p = const_cast<char*>(pc);  //正确，但是通过p写值是未定义的行为
 ```
 * 对于将常量对象转换成非常量对象的行为，称为“去掉const性质（cast away the const）”。一旦去掉了某个对象的const性质，编译器将不再阻止对该对象进行写操作。如果对象本事不是一个常量，使用强制类型转换获得写权限是合法的行为。如果对象是一个常量，再使用const_cast执行写操作会产生为定义的后果。
 * 只有const_cast能改变表达式的常量属性，使用其他形式的命名强制转换改变表达式的常量属性都将引发编译错误。同样，也不能用const_cast改变表达式的类型。
```
const char *cp;
char *q = static_cast<char*>(cp);   //错误：static_cast不能转换掉const性质
static_cast<string>(cp);            //正确：字符串字面值转换成string类型
const_cast<string>(cp);             //错误：const_cast只改变常量属性
```
  * const_cast常常用于有函数重载的上下文中。


+ reinterpret_cast
 * reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。如下：
```
 int *ip;
 char *pc = reinterpret_cast<char*>(ip);
 
 //必须时刻牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。
 string str(pc);  //可能导致异常的运行时行为
```

 * 使用reniterpret_cast非常危险，上面的例子就证明了这一点。其中的关键问题是类型改变了，但是编译器没有给出任何警告或者错误的提示信息。当用int的地址初始化pc时，由于显式地声称这种转换合法，所以编译器不会发出任何警告或错误信息。但是在使用pc时会认定它的值时是char*类型，编译器没法知道它实际存放的是指向int的指针。最终的结果是，在上面的例子中虽然用pc初始化str没什么实际意义，甚至还可能引发更糟糕的后果，但仅从语法上而言这种操作无可指摘。查找这类问题的原因非常困难，如果将ip强制转换成pc的语句和用pc初始化string对象的语句分属不同文件更是如此。
 * !! reniterpret_cast本质傻姑娘依赖于机器。要想安全地使用reniterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。
+ 建议：避免强制类型转换
  * 强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。
  * 该建议对reniterpret_cast尤其适用，因为此类类型转换总是充满了风险。
  * 在有重载函数的上下文中使用const_cast无可厚非；但在其他情况下使用const_cast也就意味着程序存在某种设计缺陷。
  * 其他强制类型转换，比如static_cast和dynamic_cast，都不应该频繁使用。每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样就可以减少错误发生的机会。
  
#### 旧式的强制类型转换
* 在早期版本的C＋＋语言中，显式地进行强制类型转换包含两种形式：
```
type (expr);  //函数形式的强制类型转换
(type) expr;  // C语言风格的强制类型转换 
```
* 根据所涉及的类型不同，旧式的强制类型转换分别具有与const_cast,static_cast或reinterpret_cast相似的行为。当在某处执行旧式的强制类型转换时，如果换成const_cast和static_cast也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与reniterpret_cast类似的功能：
```
char *pc = (char*) ip; //ip是指向整数的指针，效果与使用reniterpret_cast一样。
```
 
