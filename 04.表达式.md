#### 重载运算符 overloaded operator
+ 使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数，运算符的优先级和结合律都是无法改变的。

+ 要用到左值的运算符
  * 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果仍是一个左值
  * 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
  * 内置解引用运算符，下标运算符，迭代器解引用运算符，string和vector的下标运算符的求职结果都是左值。
  * 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值
  
 #### 求值顺序
+ 有4种运算符明确规定了运算对象的求值顺序：
   * 逻辑与（&&）运算符
   * 逻辑或（｜｜）运算符
   * 条件（？：）运算符
   * 逗号（，）运算符
   
#### 递增和递减运算符
+ 前置版本将对象本身作为左值返回；后置版本则将对象原始值的副本作为右值返回。 所以除非必须，否则不用递增递减运算符的后置版本。

#### 成员访问运算符
+ 点运算符获取对象的一个成员
+ 箭头运算符与点运算符有关，ptr->mem <=> (*ptr).mem
```
string s1 = "a string", *p = &s1;
auto n = s1.size();  //运行string对象s1的size成员
n = (*p).size();     //运行p所指对象的size成员，括号必不可少，因为解引用运算符的优先级低于点运算符
n = p->size();       //等价于(*p).size() 
```

#### 条件运算符（？：）
+ cond? expr1:expr2; 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则运算的结果是右值。

#### sizeof运算符
+ sizeof (type)和sizeof expr两种形式
+ C++11允许使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须提供一个具体的对象，因为想知道类成员的大小无须真的获取该成员。
