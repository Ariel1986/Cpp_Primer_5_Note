+ 类的基本思想是数据抽象（data abstraction）和封装（encapsulation).
+ 数据抽象是一种依赖于借口（interface）和实现（implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。
+ 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

### 定义类的成员函数
+ 定义在类内部的函数是隐式的inline函数。
+ 所有的成员函数都必须在类的内部声明，但是成员函数体可以定义在类内部也可以定义在类外。

### 引入this
+ 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当调用一个成员函数时，用请求该函数的对象地址初始化this。
+ 在成员函数内部，可以直接使用调用该函数的对象的成员，无须通过成员访问运算符来这么做。
+ 因为this的目的是指向“这个”对象，所以this是一个常量指针，不能改变this中保存的地址。

### 构造函数 constructor
+ 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
+ 构造函数不能被声明成const的。当创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

#### 合成的默认构造函数（default constructor）
+ 如果类没有显式地定义构造函数，编译器会隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）
+ 合成的默认构造函数按照如下规则初始化类的数据成员
  * 如果存在类内的初始值，用它来初始化成员。
  * 否则，默认初始化该成员。
+ 在c＋＋11新标准中，如果需要默认的行为，可以通过在参数列表后面写上＝default要求编译器生成构造函数。其中，＝default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果=default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。
+ 没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

### 友元
+ 友元声明只能出现在类定义的内部，但是在类内部出现的具体位置不限。友元不是类的成员，所以不受它所在区域访问控制级别的约束。
+ 一般来说，最好在类定义开始或结束前的位置集中声明友元。
+ 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望用户能够访问某个友元函数，必须在友元声明之外再队函数进行一次声明。
+ 为了使友元对类的用户可见，通常把友元的声明与类本身放置在同一个头文件中（类的外部）。

#### 类之间的友元关系
+ 类可以把其他的类定义成友元，可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。
```
class Screen{
 friend class Window_mgr; //Window_mgr可以访问Screen类的私有部分
}
```
+ 友元关系不存在传递性。每个类负责控制自己的友元类或者友元函数。
+ 令成员函数作为友元。但是必须按照如下方式设计程序：
 * 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。
 * 然后定义Screen，包括对于clear的友元声明。
 * 最后定义clear，此时它才可以使用Screen的成员。
```
class Screen{
 friend void Window_mgr::clear(ScreenIndex); //Window_mgr::clear必须在Screen类之前被声明
}
```
### 内联函数
+ 定义在类内部的函数是自动inline的。
+ 可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义。

### 类数据成员的初始值
+ 提供一个类内初始值时，必须以符号＝或者花括号表示
+ 如果成员是const，引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值。
+ 如果一个构造函数为所有参数都提供了默认实参，则它实际上野定义了默认构造函数。

### 委托构造函数 delegating constructor
+ 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。

### 默认构造函数的作用
+ 当对象被默认初始化或值初始化时自动执行默认构造函数。
+ 默认初始化在以下情况发生：
 * 当在块作用域内不使用任何初始值定义一个非静态变量或者数组时
 * 当一个类本身含有类类型的成员且使用合成的默认构造函数时
 * 当类类型的成员没有在构造函数初始值列表中显式地初始化时
+ 值初始化在以下情况发生：
 * 在数组初始化的过程中如果提供的初始值数量少于数组的大小
 * 不使用初始值定义一个局部静态变量时
 * 通过书写形如T（）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就像是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

+ 如果定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对：
```
Sale_data obj();  //错误：声明了一个函数而非对象
Sale_data obj2;   //正确：obj2是一个对象而非函数
```
