+ 类的基本思想是数据抽象（data abstraction）和封装（encapsulation).
+ 数据抽象是一种依赖于借口（interface）和实现（implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。
+ 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

### 定义类的成员函数
+ 定义在类内部的函数是隐式的inline函数。
+ 所有的成员函数都必须在类的内部声明，但是成员函数体可以定义在类内部也可以定义在类外。

### 引入this
+ 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当调用一个成员函数时，用请求该函数的对象地址初始化this。
+ 在成员函数内部，可以直接使用调用该函数的对象的成员，无须通过成员访问运算符来这么做。
+ 因为this的目的是指向“这个”对象，所以this是一个常量指针，不能改变this中保存的地址。

### 构造函数 constructor
+ 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
+ 构造函数不能被声明成const的。当创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

#### 合成的默认构造函数（default constructor）
+ 如果类没有显式地定义构造函数，编译器会隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）
+ 合成的默认构造函数按照如下规则初始化类的数据成员
  * 如果存在类内的初始值，用它来初始化成员。
  * 否则，默认初始化该成员。
+ 在c＋＋11新标准中，如果需要默认的行为，可以通过在参数列表后面写上＝default要求编译器生成构造函数。其中，＝default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果=default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。
+ 没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

### 友元
+ 友元声明只能出现在类定义的内部，但是在类内部出现的具体位置不限。友元不是类的成员，所以不受它所在区域访问控制级别的约束。
+ 一般来说，最好在类定义开始或结束前的位置集中声明友元。
+ 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望用户能够访问某个友元函数，必须在友元声明之外再队函数进行一次声明。
+ 为了使友元对类的用户可见，通常把友元的声明与类本身放置在同一个头文件中（类的外部）。

#### 类之间的友元关系
+ 类可以把其他的类定义成友元，可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。
```
class Screen{
 friend class Window_mgr; //Window_mgr可以访问Screen类的私有部分
}
```
+ 友元关系不存在传递性。每个类负责控制自己的友元类或者友元函数。
+ 令成员函数作为友元。但是必须按照如下方式设计程序：
 * 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。
 * 然后定义Screen，包括对于clear的友元声明。
 * 最后定义clear，此时它才可以使用Screen的成员。
```
class Screen{
 friend void Window_mgr::clear(ScreenIndex); //Window_mgr::clear必须在Screen类之前被声明
}
```
### 内联函数
+ 定义在类内部的函数是自动inline的。
+ 可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义。

### 类数据成员的初始值
+ 提供一个类内初始值时，必须以符号＝或者花括号表示
+ 如果成员是const，引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值。
+ 如果一个构造函数为所有参数都提供了默认实参，则它实际上野定义了默认构造函数。

### 委托构造函数 delegating constructor
+ 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。

### 默认构造函数的作用
+ 当对象被默认初始化或值初始化时自动执行默认构造函数。
+ 默认初始化在以下情况发生：
 * 当在块作用域内不使用任何初始值定义一个非静态变量或者数组时
 * 当一个类本身含有类类型的成员且使用合成的默认构造函数时
 * 当类类型的成员没有在构造函数初始值列表中显式地初始化时
+ 值初始化在以下情况发生：
 * 在数组初始化的过程中如果提供的初始值数量少于数组的大小
 * 不使用初始值定义一个局部静态变量时
 * 通过书写形如T（）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就像是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

+ 如果定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对：
```
Sale_data obj();  //错误：声明了一个函数而非对象
Sale_data obj2;   //正确：obj2是一个对象而非函数
```
### 隐式的类类型转换
+ 能通过一个实参调用的构造函数定义类一条从构造函数的参数类型向类类型隐转换的规则
+ 可以通过将构造函数声明为explicit阻止构造函数定义的隐式转换
```
class Sale_data{
public:
 explicit Sale_data(const std::string& s) : bookNo(s) {}
 //... 
};
```
+ 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit。
+ 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。
+ explicit构造函数只能用于直接初始化
```
Sale_data item1(null_book);  //正确，直接初始化
Sale_data item2 = nullbook;  //错误：不能将explicit构造函数用于拷贝形式的初始化过程
```

### 聚合类（aggregate class）
+ 聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式，当一个类满足如下条件时，说它是聚合的：
 * 所有成员都是public的
 * 没有定义任何构造函数
 * 没有类内初始值
 * 没有基类，也没有virtual函数
 
### 字面值常量类
+ 和其他类不同，字面值类型的类可能含有constexpr函数成员，这样的成员必须符合constexpr函数的所有要求，他们是隐式const的。
#### constexpr构造函数
+ 尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。
+ constexpr构造函数可以声明称＝default的形式或者是删除函数的形式。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的。通过前置关键字constexpr就可以声明一个constexpr构造函数
+ constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数或者是一条常量表达式。
+ constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型
```
class Debug{
public:
 constexpr Debug(bool b=true) : hw(b), io(b), other(b) {}
private:
 bool hw;
 bool io;
 bool other;
};
```

### 类的静态成员
+ 和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量，引用，指针，类类型等。
+ 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据有关的数据。
+ 类的静态成员函数也不与任何对象绑定在一起，他们不包含this指针。作为结果，静态成员函数不能声明成const的，而且也不能在static函数体内使用this指针。这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。
#### 使用类的静态成员
+ 使用作用域运算符直接访问静态成员：
```
double r;
r = Account::rate();  //使用作用域运算符访问静态成员
```
+ 使用类的对象，引用或者指针访问静态成员
```
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate();   // 通过Account的对象或引用
r = ac2->rate();  // 通过指向Account对象的指针
```
+ 成员函数不用通过作用域运算符就能直接使用静态成员
```
class Account {
public:
 void calculate() { amount += amount * interestRate; }
private:
 static double interestRate;
 //...
};
```
#### 定义静态成员
+ 静态成员函数：和其他成员函数一样，既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句
```
//在类的外部定义类的静态函数成员，必须指明成员所属的类名。static关键字只出现在类内部的声明语句中
void Account::rate(double newRate)
{
 interestRate = newRate;
}
```
+ 静态数据成员：因为静态数据成员不属于类的任何一个对象，所以它们不是在创建类的对象时被定义的，也就是说它们不是由构造函数初始化的。
+ 一般，不在类的内部初始化静态成员。相反，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。
+ 类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中
+ 定义静态数据成员的方式类似于在类的外部定义成员函数，需要指定对象的类型名，类名，作用域运算符以及成员自己的名字：
```
double Account::interestRate = initRate(); //定义并初始化一个静态成员
```
+ 想要确保对象只定义一次，最好的办法就是把静态数据成员的定义与其它非内联函数的定义放在同一个文件中。

#### 静态成员的类内初始化
+ 通常情况下，类的静态成员不应该在类的内部初始化。然而，可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。
+ 初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适用于常量表达式的地方
```
class Account {
public:
 static double rate() {return interestRate;}
 static void rate(double);
private:
 static constexpr int period = 30;  //period是常量表达式
 double daily[period];
};

constexpr int Accout::period; //初始值在类的定义内提供
```
+ 即使一个常量静态数据成员在类内部被初始化了，通常情况下页应该在类的外部定义一下该成员。

#### 静态成员能用于某些场景，而普通成员不能
+ 静态成员可以是不完全类型：静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用
+ 可以使用静态成员作为默认实参，非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。
```
class Screen {
public:
 Screen& clear(char = bkground);
private:
 static const char bkgroud;
};
```
+ 
